!function(e){var n={};function r(o){if(n[o])return n[o].exports;var t=n[o]={i:o,l:!1,exports:{}};return e[o].call(t.exports,t,t.exports,r),t.l=!0,t.exports}r.m=e,r.c=n,r.d=function(e,n,o){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:o})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(r.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var t in e)r.d(o,t,function(n){return e[n]}.bind(null,t));return o},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s="./test/src/test.ts")}({"./app/src/actor.ts":
/*!**************************!*\
  !*** ./app/src/actor.ts ***!
  \**************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Actor = exports.Gender = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _doctor = __webpack_require__(/*! ./doctor */ "./app/src/doctor.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Actor class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Gender = exports.Gender = undefined;\n(function (Gender) {\n    Gender[Gender["male"] = 0] = "male";\n    Gender[Gender["female"] = 1] = "female";\n})(Gender || (exports.Gender = Gender = {}));\n/**\n * Creates a new Actor\n * @class\n */\n\nvar Actor = exports.Actor = function () {\n    function Actor() {\n        _classCallCheck(this, Actor);\n    }\n\n    _createClass(Actor, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Actor instance\n         * @returns {Actor}\n         */\n        value: function addHATEAOS() {\n            return Actor.addHATEAOSTo(this);\n        }\n        /**\n         * Returns a new Actor object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Actor\n         * @returns {Actor}\n         * @static\n         */\n\n    }], [{\n        key: "restv1URL",\n\n        /**\n         * Returns the canonical REST API v1 endpoint for a Actor\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n        value: function restv1URL(id) {\n            return "/v1/actors/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Actor object\n         * @param {Actor} Object representing a Actor\n         * @returns {Actor}\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(actor) {\n            actor.links = [];\n            actor.links.push({ rel: "self", href: Actor.restv1URL(actor.id) });\n            return actor;\n        }\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var actor = new Actor();\n            row.id ? actor.id = row.id : undefined;\n            row.name ? actor.name = row.name : undefined;\n            row.gender ? actor.gender = row.gender : undefined;\n            return actor;\n        }\n        /**\n         * Returns a single Actor object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Actor database ID\n         * @returns {Actor}\n         */\n\n    }, {\n        key: "forID",\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM actors WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Actor.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Actor objects in the system\n         * @param {Database} connection SQLite connection\n         * @returns {Array} Array of Actor objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM actors ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Actor.fromRow(x).addHATEAOS();\n                            }));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Actor by the Actor\'s name\n         * @param {object} connection SQLite connection\n         * @param {string} name The Actor\'s name\n         * @returns {Promise} Single Actor record\n         */\n\n    }, {\n        key: "forName",\n        value: function forName(connection, name) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM actors WHERE name = ?\', [name], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Actor.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Actor by the Actor\'s gender\n         * @param {object} connection SQLite connection\n         * @param {Gender} gender The Actor\'s gender\n         * @returns {Array} Array of Actor objects\n         */\n\n    }, {\n        key: "forGender",\n        value: function forGender(connection, gender) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM actors WHERE gender = ?\', [gender], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Actor.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Doctor objects for a given Actor ID\n         * @param {object} connection SQLite connection\n         * @param {number} actorID Actor database ID\n         * @returns {Array} Array of Doctor objects\n         */\n\n    }, {\n        key: "doctors",\n        value: function doctors(connection, actorID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT doctors.* FROM doctors WHERE doctors.primary_actor = ? ORDER BY doctors.id\', [actorID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _doctor.Doctor.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n    }]);\n\n    return Actor;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Actor, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Actor, "all", null);\n__decorate([_memoizedClassDecorator2.default], Actor, "forName", null);\n__decorate([_memoizedClassDecorator2.default], Actor, "forGender", null);\n__decorate([_memoizedClassDecorator2.default], Actor, "doctors", null);\n\n//# sourceURL=webpack:///./app/src/actor.ts?')},"./app/src/companion.ts":
/*!******************************!*\
  !*** ./app/src/companion.ts ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Companion = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _serial = __webpack_require__(/*! ./serial */ "./app/src/serial.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Companion class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Companion\n * @class\n */\nvar Companion = exports.Companion = function () {\n    function Companion() {\n        _classCallCheck(this, Companion);\n    }\n\n    _createClass(Companion, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Companion instance\n         * @returns {Companion}\n         */\n        value: function addHATEAOS() {\n            return Companion.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Companion object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Companion database ID\n         * @returns {Promise}\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM companions WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Companion.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Companion objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Companion objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM companions ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Companion.fromRow(x).addHATEAOS();\n                            }));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Companion by the Companion\'s name\n         * @param {object} connection SQLite connection\n         * @param {string} name The Companion\'s name\n         * @returns {Promise} Single Companion record\n         */\n\n    }, {\n        key: "forName",\n        value: function forName(connection, name) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM companions WHERE name = ?\', [name], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Companion.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Companion objects for a given serial ID\n         * @param {object} connection SQLite connection\n         * @param {number} serialID Serial database ID\n         * @returns {Array} Array of Companion objects\n         */\n\n    }, {\n        key: "forSerialID",\n        value: function forSerialID(connection, serialID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT companions.* FROM serials INNER JOIN serials_companions ON serials.id = serials_companions.serial_id INNER JOIN companions ON serials_companions.companion_id = companions.id WHERE serials.id = ?\', [serialID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Companion.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects for a given Companion ID\n         * @param {object} connection SQLite connection\n         * @param {number} companionID Companion database ID\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "serials",\n        value: function serials(connection, companionID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT serials.* FROM serials INNER JOIN serials_companions ON serials.id = serials_companions.serial_id INNER JOIN companions ON serials_companions.companion_id = companions.id WHERE companions.id = ? ORDER BY serials.id\', [companionID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _serial.Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Companion object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Companion\n         * @returns {Companion}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var companion = new Companion();\n            row.id ? companion.id = row.id : undefined;\n            row.name ? companion.name = row.name : undefined;\n            return companion;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Companion\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/companions/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Companion object\n         * @param {Companion} Object representing a Companion\n         * @returns {Companion}\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(companion) {\n            companion.links = [];\n            companion.links.push({ rel: "self", href: Companion.restv1URL(companion.id) });\n            return companion;\n        }\n    }]);\n\n    return Companion;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Companion, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Companion, "all", null);\n__decorate([_memoizedClassDecorator2.default], Companion, "forName", null);\n__decorate([_memoizedClassDecorator2.default], Companion, "forSerialID", null);\n__decorate([_memoizedClassDecorator2.default], Companion, "serials", null);\n\n//# sourceURL=webpack:///./app/src/companion.ts?')},"./app/src/director.ts":
/*!*****************************!*\
  !*** ./app/src/director.ts ***!
  \*****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Director = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _serial = __webpack_require__(/*! ./serial */ "./app/src/serial.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Director class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Director\n * @class\n */\nvar Director = exports.Director = function () {\n    function Director() {\n        _classCallCheck(this, Director);\n    }\n\n    _createClass(Director, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Director instance\n         * @returns {Director}\n         */\n        value: function addHATEAOS() {\n            return Director.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Director object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Director database ID\n         * @returns {Promise}\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM directors WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Director.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Director objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Director objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM directors ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Director.fromRow(x).addHATEAOS();\n                            }));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Director by the Director\'s name\n         * @param {object} connection SQLite connection\n         * @param {string} name The Director\'s name\n         * @returns {Promise} Single Director record\n         */\n\n    }, {\n        key: "forName",\n        value: function forName(connection, name) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM directors WHERE name = ?\', [name], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Director.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Director objects for a given serial ID\n         * @param {object} connection SQLite connection\n         * @param {number} serialID Serial database ID\n         * @returns {Array} Array of Director objects\n         */\n\n    }, {\n        key: "forSerialID",\n        value: function forSerialID(connection, serialID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT directors.* FROM serials INNER JOIN serials_directors ON serials.id = serials_directors.serial_id INNER JOIN directors ON serials_directors.director_id = directors.id WHERE serials.id = ?\', [serialID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Director.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects for a given Director ID\n         * @param {object} connection SQLite connection\n         * @param {number} directorID Director database ID\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "serials",\n        value: function serials(connection, directorID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT serials.* FROM serials INNER JOIN serials_directors ON serials.id = serials_directors.serial_id INNER JOIN directors ON serials_directors.director_id = directors.id WHERE directors.id = ? ORDER BY serials.id\', [directorID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _serial.Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Director object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Director\n         * @returns {Director}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var director = new Director();\n            row.id ? director.id = row.id : undefined;\n            row.name ? director.name = row.name : undefined;\n            return director;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Director\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/directors/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Director object\n         * @param {Director} Object representing a Director\n         * @returns {Director}\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(director) {\n            director.links = [];\n            director.links.push({ rel: "self", href: Director.restv1URL(director.id) });\n            return director;\n        }\n    }]);\n\n    return Director;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Director, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Director, "all", null);\n__decorate([_memoizedClassDecorator2.default], Director, "forName", null);\n__decorate([_memoizedClassDecorator2.default], Director, "forSerialID", null);\n__decorate([_memoizedClassDecorator2.default], Director, "serials", null);\n\n//# sourceURL=webpack:///./app/src/director.ts?')},"./app/src/doctor.ts":
/*!***************************!*\
  !*** ./app/src/doctor.ts ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Doctor = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _serial = __webpack_require__(/*! ./serial */ "./app/src/serial.ts");\n\nvar _actor = __webpack_require__(/*! ./actor */ "./app/src/actor.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Doctor class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Doctor\n * @class\n */\nvar Doctor = exports.Doctor = function () {\n    function Doctor() {\n        _classCallCheck(this, Doctor);\n    }\n\n    _createClass(Doctor, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Doctor instance\n         * @returns {Doctor}\n         */\n        value: function addHATEAOS() {\n            return Doctor.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Doctor object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Doctor database ID\n         * @returns {Promise} Single Doctor record\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM doctors WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Doctor.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Doctor object for a given incarnation name\n         * @param {object} connection SQLite connection\n         * @param {string} incarnation Doctor incarnation name\n         * @returns {Promise} Single Doctor record\n         */\n\n    }, {\n        key: "forIncarnation",\n        value: function forIncarnation(connection, incarnation) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM doctors WHERE incarnation = ?\', [incarnation], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Doctor.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Doctor object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} primaryActorID Doctor database ID\n         * @returns {Promise} Single Doctor record\n         */\n\n    }, {\n        key: "forPrimaryActorID",\n        value: function forPrimaryActorID(connection, primaryActorID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM doctors WHERE primary_actor = ?\', [primaryActorID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Doctor.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Actor objects for a given Doctor ID\n         * @param {object} connection SQLite connection\n         * @param {number} doctorID Doctor database ID\n         * @returns {Array} Array of Actor objects\n         */\n\n    }, {\n        key: "actors",\n        value: function actors(connection, doctorID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT actors.* FROM actors INNER JOIN doctors ON actors.id = doctors.primary_actor WHERE doctors.id = ? ORDER BY actors.id\', [doctorID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _actor.Actor.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Doctor objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Promise} Array of Doctor objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM doctors ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Doctor.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Doctor objects for a given serial ID\n         * @param {object} connection SQLite connection\n         * @param {number} serialID Serial database ID\n         * @returns {Array} Array of Doctor objects\n         */\n\n    }, {\n        key: "forSerialID",\n        value: function forSerialID(connection, serialID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT doctors.* FROM serials INNER JOIN serials_doctors ON serials.id = serials_doctors.serial_id INNER JOIN doctors ON serials_doctors.doctor_id = doctors.id WHERE serials.id = ?\', [serialID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Doctor.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects for a given Doctor ID\n         * @param {object} connection SQLite connection\n         * @param {number} doctorID Doctor database ID\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "serials",\n        value: function serials(connection, doctorID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT serials.* FROM serials INNER JOIN serials_doctors ON serials.id = serials_doctors.serial_id INNER JOIN doctors ON serials_doctors.doctor_id = doctors.id WHERE doctors.id = ? ORDER BY serials.id\', [doctorID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _serial.Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Doctor object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Doctor\n         * @returns {Doctor}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var doctor = new Doctor();\n            row.id ? doctor.id = row.id : undefined;\n            row.incarnation ? doctor.incarnation = row.incarnation : undefined;\n            row.primary_actor ? doctor.primaryActorID = row.primary_actor : undefined;\n            return doctor;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Doctor\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/doctors/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Doctor object\n         * @param {Doctor} Object representing a Doctor\n         * @returns {Doctor}\n         * @static\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(doctor) {\n            doctor.links = [];\n            doctor.links.push({ rel: "self", href: Doctor.restv1URL(doctor.id) });\n            return doctor;\n        }\n    }]);\n\n    return Doctor;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Doctor, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "forIncarnation", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "forPrimaryActorID", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "actors", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "all", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "forSerialID", null);\n__decorate([_memoizedClassDecorator2.default], Doctor, "serials", null);\n\n//# sourceURL=webpack:///./app/src/doctor.ts?')},"./app/src/episode.ts":
/*!****************************!*\
  !*** ./app/src/episode.ts ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Episode = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Episode class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Episode\n * @class\n */\nvar Episode = exports.Episode = function () {\n    function Episode() {\n        _classCallCheck(this, Episode);\n    }\n\n    _createClass(Episode, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Episode instance\n         * @returns {Episode}\n         */\n        value: function addHATEAOS() {\n            return Episode.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Episode object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Episode database ID\n         * @returns {Episode}\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM episodes WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Episode.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({\n                            error: {\n                                message: \'Error while performing Query.\'\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Episode objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Episode objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM episodes ORDER BY serial_id, episode_order\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Episode.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Episode objects for a given serial ID\n         * @param {object} connection SQLite connection\n         * @param {number} serialID Serial database ID\n         * @returns {Array} Array of Episode objects\n         */\n\n    }, {\n        key: "forSerialID",\n        value: function forSerialID(connection, serialID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT episodes.* FROM episodes WHERE episodes.serial_id = ?\', [serialID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Episode.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Episode objects with a given title\n         * @param {object} connection SQLite connection\n         * @param {string} title Episode title\n         * @returns {Array} Array of Episode objects\n         */\n\n    }, {\n        key: "forTitle",\n        value: function forTitle(connection, title) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT episodes.* FROM episodes WHERE episodes.title = ?\', [title], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Episode.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Episode objects that premiered on a given date\n         * @param {object} connection SQLite connection\n         * @param {string} originalAirDate Original air date\n         * @returns {Array} Array of Episode objects\n         */\n\n    }, {\n        key: "forOriginalAirDate",\n        value: function forOriginalAirDate(connection, originalAirDate) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT episodes.* FROM episodes WHERE episodes.original_air_date = ?\', [originalAirDate], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Episode.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Episode objects with a given "missing" status\n         * @param {object} connection SQLite connection\n         * @param {boolean} missing "Missing" status\n         * @returns {Array} Array of Episode objects\n         */\n\n    }, {\n        key: "forMissingStatus",\n        value: function forMissingStatus(connection, missing) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT episodes.* FROM episodes WHERE episodes.missing = ?\', [ true && missing], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Episode.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for an Episode\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/episodes/" + id;\n        }\n        /**\n         * Adds HATEAOS data to an Episode object\n         * @param {Episode} Object representing a Episode\n         * @returns {Episode}\n         * @static\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(episode) {\n            episode.links = [];\n            episode.links.push({\n                rel: "self",\n                href: Episode.restv1URL(episode.id)\n            });\n            return episode;\n        }\n    }]);\n\n    return Episode;\n}();\n/**\n * Returns a new Epiosode object populated from a basic JavaScript object (database result row)\n * @param {object} row Object with fields to copy to a new Episode\n * @returns {Episode}\n * @static\n */\n\n\nEpisode.fromRow = function (row) {\n    var episode = new Episode();\n    row.id ? episode.id = row.id : undefined;\n    row.title ? episode.title = row.title : undefined;\n    row.serial_id ? episode.serialID = row.serial_id : undefined;\n    row.episode_order ? episode.episodeOrder = row.episode_order : undefined;\n    row.original_air_date ? episode.originalAirDate = row.original_air_date : undefined;\n    row.runtime ? episode.runtime = row.runtime : undefined;\n    row.uk_viewers_mm ? episode.ukViewersMM = row.uk_viewers_mm : undefined;\n    row.appreciation_index ? episode.appreciationIndex = row.appreciation_index : undefined;\n    row.missing ? episode.missing = row.missing === 1 : undefined;\n    row.recreated ? episode.recreated = row.recreated === 1 : undefined;\n    return episode;\n};\n__decorate([_memoizedClassDecorator2.default], Episode, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Episode, "all", null);\n__decorate([_memoizedClassDecorator2.default], Episode, "forSerialID", null);\n__decorate([_memoizedClassDecorator2.default], Episode, "forTitle", null);\n__decorate([_memoizedClassDecorator2.default], Episode, "forOriginalAirDate", null);\n__decorate([_memoizedClassDecorator2.default], Episode, "forMissingStatus", null);\n\n//# sourceURL=webpack:///./app/src/episode.ts?')},"./app/src/season.ts":
/*!***************************!*\
  !*** ./app/src/season.ts ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Season = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _serial = __webpack_require__(/*! ./serial */ "./app/src/serial.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Season class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Season\n * @class\n */\nvar Season = exports.Season = function () {\n    function Season() {\n        _classCallCheck(this, Season);\n    }\n\n    _createClass(Season, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Season instance\n         * @returns {Season}\n         */\n        value: function addHATEAOS() {\n            return Season.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Season object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Season database ID\n         * @returns {Season}\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM seasons WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Season.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Season by the Season\'s name ("Season X", "Series X")\n         * @param {object} connection SQLite connection\n         * @param {string} name The Season\'s name\n         * @returns {Promise} Single Season record\n         */\n\n    }, {\n        key: "forName",\n        value: function forName(connection, name) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM seasons WHERE name = ?\', [name], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Season.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects for a given Season ID\n         * @param {object} connection SQLite connection\n         * @param {number} seasonID Season database ID\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "serials",\n        value: function serials(connection, seasonID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT serials.* FROM serials WHERE serials.season_id = ? ORDER BY serials.id\', [seasonID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _serial.Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Season objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Season objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM seasons ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Season.fromRow(x).addHATEAOS();\n                            }));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Season object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Season\n         * @returns {Season}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var season = new Season();\n            row.id ? season.id = row.id : undefined;\n            row.name ? season.name = row.name : undefined;\n            return season;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Season\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/seasons/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Season object\n         * @param {Season} Object representing a Season\n         * @returns {Season}\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(season) {\n            season.links = [];\n            season.links.push({ rel: "self", href: Season.restv1URL(season.id) });\n            return season;\n        }\n    }]);\n\n    return Season;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Season, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Season, "forName", null);\n__decorate([_memoizedClassDecorator2.default], Season, "serials", null);\n__decorate([_memoizedClassDecorator2.default], Season, "all", null);\n\n//# sourceURL=webpack:///./app/src/season.ts?')},"./app/src/serial.ts":
/*!***************************!*\
  !*** ./app/src/serial.ts ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Serial = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Serial class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Serial\n * @class\n */\nvar Serial = exports.Serial = function () {\n    function Serial() {\n        _classCallCheck(this, Serial);\n    }\n\n    _createClass(Serial, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Serial instance\n         * @returns {Serial}\n         */\n        value: function addHATEAOS() {\n            return Serial.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n         * Returns a single Serial object for a given database ID\n         * @param {object} connection SQLite connection\n         * @param {number} id Serial database ID\n         * @returns {Promise<Array<Serial>>}\n         */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM serials WHERE id = ?\', [id], function (err, rows /*, fields */) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve([Serial.fromRow(rows[0]).addHATEAOS()]);\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Season by the Serial\'s title\n         * @param {object} connection SQLite connection\n         * @param {string} name The Serial\'s name\n         * @returns {Promise<Serial>} Single Serial record\n         */\n\n    }, {\n        key: "forTitle",\n        value: function forTitle(connection, title) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM serials WHERE title = ?\', [title], function (err, rows /*, fields */) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Serial.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM serials ORDER BY id\', [], function (err, rows /*, fields */) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Serial object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Serial\n         * @returns {Serial}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var serial = new Serial();\n            row.id ? serial.id = row.id : undefined;\n            row.season_id ? serial.seasonID = row.season_id : undefined;\n            row.story ? serial.story = row.story : undefined;\n            row.serial ? serial.serial = row.serial : undefined;\n            row.title ? serial.title = row.title : undefined;\n            row.production_code ? serial.productionCode = row.production_code : undefined;\n            return serial;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Serial\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/serials/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Serial object\n         * @param {Serial} Object representing a Serial\n         * @returns {Serial}\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(serial) {\n            serial.links = [];\n            serial.links.push({ rel: "self", href: Serial.restv1URL(serial.id) });\n            return serial;\n        }\n    }]);\n\n    return Serial;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Serial, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Serial, "forTitle", null);\n__decorate([_memoizedClassDecorator2.default], Serial, "all", null);\n\n//# sourceURL=webpack:///./app/src/serial.ts?')},"./app/src/writer.ts":
/*!***************************!*\
  !*** ./app/src/writer.ts ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.Writer = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nvar _serial = __webpack_require__(/*! ./serial */ "./app/src/serial.ts");\n\nvar _memoizedClassDecorator = __webpack_require__(/*! memoized-class-decorator */ "memoized-class-decorator");\n\nvar _memoizedClassDecorator2 = _interopRequireDefault(_memoizedClassDecorator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * @file Writer class\n * @author Dana Ross <dana@danaross.dev>\n */\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/**\n * Creates a new Writer\n * @class\n */\nvar Writer = exports.Writer = function () {\n    function Writer() {\n        _classCallCheck(this, Writer);\n    }\n\n    _createClass(Writer, [{\n        key: "addHATEAOS",\n\n        /**\n         * Adds HATEAOS data to the current Writer instance\n         * @returns {Writer}\n         */\n        value: function addHATEAOS() {\n            return Writer.addHATEAOSTo(this);\n        }\n    }], [{\n        key: "forID",\n\n        /**\n        * Returns a single Writer object for a given database ID\n        * @param {object} connection SQLite connection\n        * @param {number} id Writer database ID\n        * @returns {Writer}\n        */\n        value: function forID(connection, id) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM writers WHERE id = ?\', [id], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Writer.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Writer objects in the system\n         * @param {object} connection SQLite connection\n         * @returns {Array} Array of Writer objects\n         */\n\n    }, {\n        key: "all",\n        value: function all(connection) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM writers ORDER BY id\', [], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Writer.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a single Writer by the Writers\'s name\n         * @param {object} connection SQLite connection\n         * @param {string} name The Writer\'s name\n         * @returns {Promise} Single Writer record\n         */\n\n    }, {\n        key: "forName",\n        value: function forName(connection, name) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT * FROM writers WHERE name = ?\', [name], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(Writer.fromRow(rows[0]).addHATEAOS());\n                        } else {\n                            resolve();\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Writer objects for a given Serial ID\n         * @param {object} connection SQLite connection\n         * @param {number} serialID Serial database ID\n         * @returns {Array} Array of Writer objects\n         */\n\n    }, {\n        key: "forSerialID",\n        value: function forSerialID(connection, serialID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT writers.* FROM serials INNER JOIN serials_writers ON serials.id = serials_writers.serial_id INNER JOIN writers ON serials_writers.writer_id = writers.id WHERE serials.id = ?\', [serialID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return Writer.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns all Serial objects for a given Writer ID\n         * @param {object} connection SQLite connection\n         * @param {number} writerID Writer database ID\n         * @returns {Array} Array of Serial objects\n         */\n\n    }, {\n        key: "serials",\n        value: function serials(connection, writerID) {\n            return new Promise(function (resolve, reject) {\n                connection.all(\'SELECT serials.* FROM serials INNER JOIN serials_writers ON serials.id = serials_writers.serial_id INNER JOIN writers ON serials_writers.writer_id = writers.id WHERE writers.id = ? ORDER BY serials.id\', [writerID], function (err, rows, fields) {\n                    if (!err) {\n                        if (rows && rows.length) {\n                            resolve(rows.map(function (x) {\n                                return _serial.Serial.fromRow(x).addHATEAOS();\n                            }, rows));\n                        } else {\n                            resolve([]);\n                        }\n                    } else {\n                        reject({ error: { message: \'Error while performing Query.\' } });\n                    }\n                });\n            });\n        }\n        /**\n         * Returns a new Writer object populated from a basic JavaScript object (database result row)\n         * @param {object} row Object with fields to copy to a new Writer\n         * @returns {Writer}\n         * @static\n         */\n\n    }, {\n        key: "fromRow",\n        value: function fromRow(row) {\n            var writer = new Writer();\n            row.id ? writer.id = row.id : undefined;\n            row.name ? writer.name = row.name : undefined;\n            return writer;\n        }\n        /**\n         * Returns the canonical REST API v1 endpoint for a Writer\n         * @param {number} id Database record ID\n         * @return {string} REST API v1 endpoint URL\n         * @static\n         */\n\n    }, {\n        key: "restv1URL",\n        value: function restv1URL(id) {\n            return "/v1/writers/" + id;\n        }\n        /**\n         * Adds HATEAOS data to a Writer object\n         * @param {Writer} Object representing a Writer\n         * @returns {Writer}\n         * @static\n         */\n\n    }, {\n        key: "addHATEAOSTo",\n        value: function addHATEAOSTo(writer) {\n            writer.links = [];\n            writer.links.push({ rel: "self", href: Writer.restv1URL(writer.id) });\n            return writer;\n        }\n    }]);\n\n    return Writer;\n}();\n\n__decorate([_memoizedClassDecorator2.default], Writer, "forID", null);\n__decorate([_memoizedClassDecorator2.default], Writer, "all", null);\n__decorate([_memoizedClassDecorator2.default], Writer, "forName", null);\n__decorate([_memoizedClassDecorator2.default], Writer, "forSerialID", null);\n__decorate([_memoizedClassDecorator2.default], Writer, "serials", null);\n\n//# sourceURL=webpack:///./app/src/writer.ts?')},"./test/src/actor.ts":
/*!***************************!*\
  !*** ./test/src/actor.ts ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _actor = __webpack_require__(/*! ../../app/src/actor */ \"./app/src/actor.ts\");\n\ndescribe('Actor', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_actor.Actor.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/actors/1', _actor.Actor.restv1URL(1), 'Actor restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _actor.Actor(),\n            mutated = _actor.Actor.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_actor.Actor);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _actor.Actor(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_actor.Actor);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('instantiates a new Actor from an object or database row', function () {\n        var actor = _actor.Actor.fromRow({ id: 5, name: 'Test', gender: _actor.Gender[\"male\"], links: [] });\n    });\n}); /**\n     * @file Unit tests for the Actor class\n     */\n\n//# sourceURL=webpack:///./test/src/actor.ts?")},"./test/src/companion.ts":
/*!*******************************!*\
  !*** ./test/src/companion.ts ***!
  \*******************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _companion = __webpack_require__(/*! ../../app/src/companion */ \"./app/src/companion.ts\");\n\ndescribe('Companion', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_companion.Companion.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/companions/1', _companion.Companion.restv1URL(1), 'Companion restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _companion.Companion(),\n            mutated = _companion.Companion.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_companion.Companion);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _companion.Companion(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_companion.Companion);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('instantiates a new Companion from an object or database row', function () {\n        var instance = _companion.Companion.fromRow({ id: 5, name: 'Test', links: [] });\n        (0, _chai.expect)(instance).to.be.an.instanceof(_companion.Companion);\n        (0, _chai.expect)(instance.id).to.be.a('number');\n        (0, _chai.expect)(instance.id).to.equal(5);\n        (0, _chai.expect)(instance.name).to.be.a('string');\n        (0, _chai.expect)(instance.name).to.equal('Test');\n    });\n}); /**\n     * @file Unit tests for the Companion class\n     */\n\n//# sourceURL=webpack:///./test/src/companion.ts?")},"./test/src/director.ts":
/*!******************************!*\
  !*** ./test/src/director.ts ***!
  \******************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _director = __webpack_require__(/*! ../../app/src/director */ \"./app/src/director.ts\");\n\ndescribe('Director', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_director.Director.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/directors/1', _director.Director.restv1URL(1), 'Director restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _director.Director(),\n            mutated = _director.Director.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_director.Director);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _director.Director(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_director.Director);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('instantiates a new Director from an object or database row', function () {\n        var instance = _director.Director.fromRow({ id: 5, name: 'Test', links: [] });\n        (0, _chai.expect)(instance).to.be.an.instanceof(_director.Director);\n        (0, _chai.expect)(instance.id).to.be.a('number');\n        (0, _chai.expect)(instance.id).to.equal(5);\n        (0, _chai.expect)(instance.name).to.be.a('string');\n        (0, _chai.expect)(instance.name).to.equal('Test');\n    });\n}); /**\n     * @file Unit tests for the Director class\n     */\n\n//# sourceURL=webpack:///./test/src/director.ts?")},"./test/src/doctor.ts":
/*!****************************!*\
  !*** ./test/src/doctor.ts ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _doctor = __webpack_require__(/*! ../../app/src/doctor */ \"./app/src/doctor.ts\");\n\ndescribe('Doctor', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_doctor.Doctor.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/doctors/1', _doctor.Doctor.restv1URL(1), 'Doctor restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _doctor.Doctor(),\n            mutated = _doctor.Doctor.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_doctor.Doctor);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _doctor.Doctor(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_doctor.Doctor);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n}); /**\n     * @file Unit tests for the Doctor class\n     */\n\n//# sourceURL=webpack:///./test/src/doctor.ts?")},"./test/src/episode.ts":
/*!*****************************!*\
  !*** ./test/src/episode.ts ***!
  \*****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _episode = __webpack_require__(/*! ../../app/src/episode */ \"./app/src/episode.ts\");\n\ndescribe('Episode', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_episode.Episode.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/episodes/1', _episode.Episode.restv1URL(1), 'Episode restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _episode.Episode(),\n            mutated = _episode.Episode.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_episode.Episode);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _episode.Episode(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_episode.Episode);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n}); /**\n     * @file Unit tests for the Doctor class\n     */\n\n//# sourceURL=webpack:///./test/src/episode.ts?")},"./test/src/season.ts":
/*!****************************!*\
  !*** ./test/src/season.ts ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _season = __webpack_require__(/*! ../../app/src/season */ \"./app/src/season.ts\");\n\ndescribe('Season', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_season.Season.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/seasons/1', _season.Season.restv1URL(1), 'Season restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _season.Season(),\n            mutated = _season.Season.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_season.Season);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _season.Season(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_season.Season);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n}); /**\n     * @file Unit tests for the Doctor class\n     */\n\n//# sourceURL=webpack:///./test/src/season.ts?")},"./test/src/serial.ts":
/*!****************************!*\
  !*** ./test/src/serial.ts ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _serial = __webpack_require__(/*! ../../app/src/serial */ \"./app/src/serial.ts\");\n\ndescribe('Serial', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_serial.Serial.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/serials/1', _serial.Serial.restv1URL(1), 'Serial restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _serial.Serial(),\n            mutated = _serial.Serial.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_serial.Serial);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _serial.Serial(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_serial.Serial);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n}); /**\n     * @file Unit tests for the Doctor class\n     */\n\n//# sourceURL=webpack:///./test/src/serial.ts?")},"./test/src/test.ts":
/*!**************************!*\
  !*** ./test/src/test.ts ***!
  \**************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval('\n\n__webpack_require__(/*! ./actor.ts */ "./test/src/actor.ts");\n__webpack_require__(/*! ./director.ts */ "./test/src/director.ts");\n__webpack_require__(/*! ./doctor.ts */ "./test/src/doctor.ts");\n__webpack_require__(/*! ./episode.ts */ "./test/src/episode.ts");\n__webpack_require__(/*! ./season.ts */ "./test/src/season.ts");\n__webpack_require__(/*! ./serial.ts */ "./test/src/serial.ts");\n__webpack_require__(/*! ./writer.ts */ "./test/src/writer.ts");\n__webpack_require__(/*! ./companion.ts */ "./test/src/companion.ts");\n\n//# sourceURL=webpack:///./test/src/test.ts?')},"./test/src/writer.ts":
/*!****************************!*\
  !*** ./test/src/writer.ts ***!
  \****************************/
/*! no static exports found */function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(/*! mocha */ \"mocha\");\n\nvar _chai = __webpack_require__(/*! chai */ \"chai\");\n\nvar _writer = __webpack_require__(/*! ../../app/src/writer */ \"./app/src/writer.ts\");\n\ndescribe('Writer', function () {\n    it('generates correct restV1 URLs', function () {\n        (0, _chai.expect)(_writer.Writer.restv1URL(1)).to.be.a('string');\n        _chai.assert.equal('/v1/writers/1', _writer.Writer.restv1URL(1), 'Writer restv1URL is correct');\n    });\n    it('can add HATEAOS data to an instance', function () {\n        var original = new _writer.Writer(),\n            mutated = _writer.Writer.addHATEAOSTo(original);\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_writer.Writer);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n    it('can add HATEAOS data to the current instance', function () {\n        var original = new _writer.Writer(),\n            mutated = original.addHATEAOS();\n        (0, _chai.expect)(mutated).to.be.an.instanceof(_writer.Writer);\n        (0, _chai.expect)(mutated).to.have.property('links');\n    });\n}); /**\n     * @file Unit tests for the Doctor class\n     */\n\n//# sourceURL=webpack:///./test/src/writer.ts?")},chai:
/*!***********************!*\
  !*** external "chai" ***!
  \***********************/
/*! no static exports found */function(module,exports){eval('module.exports = require("chai");\n\n//# sourceURL=webpack:///external_%22chai%22?')},"memoized-class-decorator":
/*!*******************************************!*\
  !*** external "memoized-class-decorator" ***!
  \*******************************************/
/*! no static exports found */function(module,exports){eval('module.exports = require("memoized-class-decorator");\n\n//# sourceURL=webpack:///external_%22memoized-class-decorator%22?')},mocha:
/*!************************!*\
  !*** external "mocha" ***!
  \************************/
/*! no static exports found */function(module,exports){eval('module.exports = require("mocha");\n\n//# sourceURL=webpack:///external_%22mocha%22?')}});